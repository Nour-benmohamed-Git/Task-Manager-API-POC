import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { JwtStrategy } from './jwt.strategy';
import { UsersModule } from '../users/users.module';

@Module({
  imports: [
    // ─── UsersModule ───────────────────────────────────────────────────────────
    // AuthService and JwtStrategy both need UsersService (to find users in DB).
    // UsersService lives inside UsersModule and is listed in its exports array.
    // By importing UsersModule here, we make UsersService available for
    // injection anywhere inside AuthModule's providers (AuthService, JwtStrategy).
    UsersModule,

    // ─── PassportModule ────────────────────────────────────────────────────────
    // A NestJS wrapper that sets up the Passport.js infrastructure.
    // We don't use anything from it directly, but it must be imported so that:
    //   1. Passport middleware is initialized and active in this module.
    //   2. AuthGuard('jwt') works later when we protect routes in TasksController.
    //      Without this, @UseGuards(AuthGuard('jwt')) would throw an error.
    PassportModule,

    // ─── JwtModule ─────────────────────────────────────────────────────────────
    // Registers and configures the JWT module so that JwtService becomes
    // available for injection in AuthService (used to sign tokens on login).
    //
    // We use registerAsync (instead of register) because we need to read
    // JWT_SECRET from the .env file via ConfigService — and ConfigService
    // is only available after the app initializes, so we can't pass it statically.
    JwtModule.registerAsync({

      // Makes ConfigModule (and therefore ConfigService) available
      // inside the useFactory function below.
      // Without this, NestJS wouldn't know where to find ConfigService.
      imports: [ConfigModule],

      // Tells NestJS: "instantiate ConfigService and pass it as the first
      // argument to useFactory". This is how we get access to .env values.
      inject: [ConfigService],

      // This factory function runs at startup.
      // It receives the injected ConfigService and must return
      // the final configuration object for JwtModule.
      useFactory: (config: ConfigService) => ({

        // Reads JWT_SECRET from .env — used to sign and verify all JWT tokens.
        // If a token was signed with a different secret, verification will fail.
        secret: config.get('JWT_SECRET'),

        signOptions: {
          // Every token generated by JwtService.sign() will automatically
          // expire after 1 day. After that, the token is invalid and the
          // user must log in again to get a new one.
          expiresIn: '1d',
        },
      }),
    }),
  ],

  // ─── controllers ─────────────────────────────────────────────────────────────
  // Registers AuthController in this module.
  // NestJS will mount its routes (/auth/register, /auth/login) and
  // automatically inject AuthService into it via the constructor.
  controllers: [AuthController],

  // ─── providers ───────────────────────────────────────────────────────────────
  // Everything listed here is added to AuthModule's DI container.
  // They can inject each other and anything made available via imports above.
  providers: [
    // Contains the register() and login() business logic.
    // Injects UsersService (from UsersModule) and JwtService (from JwtModule).
    AuthService,

    // The Passport JWT strategy — defines HOW authentication works:
    // extract token from header → verify signature → call validate() → attach user.
    // Simply registering it as a provider is enough for Passport to discover
    // and activate it. No need to inject it anywhere manually.
    JwtStrategy,
  ],
})
export class AuthModule {}